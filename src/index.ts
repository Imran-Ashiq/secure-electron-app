
import { app, BrowserWindow, ipcMain, shell, session } from 'electron';
import * as keytar from 'keytar';
import * as openidClient from 'openid-client';
import * as path from 'path';
import * as dotenv from 'dotenv';
dotenv.config();

// Magic constants auto-generated by Electron Forge's Webpack plugin
// These tell Electron where to find the bundled renderer and preload scripts
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


// --- Auth0 Configuration ---
// These values are loaded from .env for security
const auth0Domain = process.env.AUTH0_DOMAIN || '';
const auth0ClientId = process.env.AUTH0_CLIENT_ID || '';

// OIDC redirect URI and secure token storage config
const redirectUri = 'myapp://auth/callback';
const keytarService = 'SecureElectronApp';
const keytarAccount = 'RefreshToken';

// Runtime state for PKCE and OIDC
let codeVerifier: string | null = null; // Stores PKCE code verifier
let mainWindow: BrowserWindow | null = null; // Main app window reference
let authConfig: openidClient.Configuration | null = null; // OIDC provider config


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// Electron Squirrel Startup: auto-quit if running installer events
if (require('electron-squirrel-startup')) {
  app.quit();
}


/**
 * Creates the main application window and applies security policies
 */
const createWindow = (): void => {
  // Create the browser window
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // Apply a strict Content Security Policy for security
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self';",
          "script-src 'self' " + (!app.isPackaged ? "'unsafe-eval'" : ""),
          "style-src 'self' 'unsafe-inline';",
          "img-src 'self' data: https://s.gravatar.com https://cdn.auth0.com https://i1.wp.com https://lh3.googleusercontent.com;",
          "connect-src 'self' " + (!app.isPackaged ? "ws://localhost:* ws://127.0.0.1:* ws://0.0.0.0:*" : ""),
        ].join(' '),
      },
    });
  });

  // Load the renderer (React) app
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};


/**
 * IPC handler: Starts the OIDC login flow when requested by renderer
 */
ipcMain.on('auth:start-login', async () => {
  console.log('Starting OIDC login flow...');

  try {
    // 1. Discover OIDC provider metadata and create config
    const config = await openidClient.discovery(
      new URL(`https://${auth0Domain}`),
      auth0ClientId,
      { redirect_uris: [redirectUri], response_types: ['code'] },
      openidClient.None()
    );

    // 2. Generate a code verifier and challenge for PKCE
    codeVerifier = openidClient.randomPKCECodeVerifier();
    const codeChallenge = await openidClient.calculatePKCECodeChallenge(codeVerifier);

    // 3. Store the OIDC config for later use
    authConfig = config;

    // 4. Construct the authorization URL for Auth0
    const authUrl = openidClient.buildAuthorizationUrl(config, {
      scope: 'openid profile email offline_access',
      response_mode: 'query',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      redirect_uri: redirectUri,
    });

    // Open the system browser for authentication
    console.log('Opening external browser for authentication...');
    await shell.openExternal(authUrl.toString());

  } catch (err) {
    console.error('Error during login flow:', err);
  }
});


/**
 * Handles the OIDC authentication callback from the browser
 * Exchanges authorization code for tokens and fetches user info
 */
function handleAuthCallback(url: string) {
  (async () => {
    if (!authConfig || !codeVerifier) {
      console.error('OIDC config or code verifier not available.');
      return;
    }

    try {
      // Exchange authorization code for tokens
      const tokenSet = await openidClient.authorizationCodeGrant(authConfig, new URL(url), {
        pkceCodeVerifier: codeVerifier,
      });

      // Store refresh token securely in OS keychain
      if (tokenSet.refresh_token) {
        await keytar.setPassword(keytarService, keytarAccount, tokenSet.refresh_token);
        console.log('Refresh token stored securely.');
      }

      // Fetch user profile info from Auth0
      let userinfo = {};
      if (tokenSet.access_token) {
        userinfo = await openidClient.fetchUserInfo(authConfig, tokenSet.access_token, openidClient.skipSubjectCheck);
      }

      console.log('Successfully retrieved tokens and user info!');
      mainWindow?.webContents.send('auth:success', userinfo);

      // Bring the app window to the front after login
      if (mainWindow) {
        if (mainWindow.isMinimized()) mainWindow.restore();
        mainWindow.focus();
      }

      // IPC handler: Logout and clear tokens
      ipcMain.on('auth:logout', async () => {
        console.log('Logging out and clearing tokens...');
        await keytar.deletePassword(keytarService, keytarAccount);
        // Optionally, redirect to Auth0 logout endpoint here
        mainWindow?.webContents.send('auth:logged-out');
      });

    } catch (err) {
      console.error('Error exchanging code for tokens:', err);
      // Optionally, send 'auth:failure' event to renderer
    }
  })();
}


// --- Electron App Lifecycle & Protocol Handling ---

/**
 * Main entry point: called when Electron is ready
 * Sets up protocol handlers and creates the main window
 */
app.on('ready', () => {
  // Enable remote debugging for Playwright tests
  if (process.env.NODE_ENV === 'test') {
    app.commandLine.appendSwitch('remote-debugging-port', '9222');
  }

  // Register custom protocol handler for OIDC callback
  if (process.defaultApp) {
    if (process.argv.length >= 2) {
      app.setAsDefaultProtocolClient('myapp', process.execPath, [path.resolve(process.argv[1])]);
    }
  } else {
    app.setAsDefaultProtocolClient('myapp');
  }

  createWindow();

  // macOS: handle OIDC callback via 'open-url' event
  app.on('open-url', (event, url) => {
    event.preventDefault();
    void handleAuthCallback(url);
  });

  // Windows/Linux: handle OIDC callback via second-instance event
  const gotTheLock = app.requestSingleInstanceLock();
  if (!gotTheLock) {
    app.quit();
  } else {
    app.on('second-instance', (event, commandLine) => {
      // Focus the main window if a second instance is launched
      if (mainWindow) {
        if (mainWindow.isMinimized()) mainWindow.restore();
        mainWindow.focus();
      }
      // Extract OIDC callback URL from command line
      const url = commandLine.pop();
      if (url && url.startsWith('myapp://')) {
        void handleAuthCallback(url);
      }
    });
  }
});


// Quit when all windows are closed, except on macOS (standard Electron behavior)
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// macOS: re-create window when dock icon is clicked and no windows are open
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


// Forward 'auth:success' from renderer (for testing and integration)
ipcMain.on('auth:success', (_event, userProfile) => {
  mainWindow?.webContents.send('auth:success', userProfile);
});
