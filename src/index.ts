import { app, BrowserWindow, ipcMain, shell, session } from 'electron';
import * as keytar from 'keytar';
import * as openidClient from 'openid-client';
import * as path from 'path';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// --- Auth0 Configuration ---
const auth0Domain = 'dev-nq5oxztl0mmatcpt.us.auth0.com'; // E.g., 'dev-12345.us.auth0.com'
const auth0ClientId = 'RB72STRzgjVlT5sLU7DRDRoqernv0hPZ';

const redirectUri = 'myapp://auth/callback';
const keytarService = 'SecureElectronApp';
const keytarAccount = 'RefreshToken';

let codeVerifier: string | null = null; // To store the verifier
let mainWindow: BrowserWindow | null = null;
let authConfig: openidClient.Configuration | null = null; // To store OIDC config

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // Apply a Content Security Policy
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self';",
          "script-src 'self' " + (!app.isPackaged ? "'unsafe-eval'" : ""),
          "style-src 'self' 'unsafe-inline';",
          "img-src 'self' data: https://s.gravatar.com https://cdn.auth0.com https://i1.wp.com https://lh3.googleusercontent.com;",
          "connect-src 'self' " + (!app.isPackaged ? "ws://localhost:* ws://127.0.0.1:* ws://0.0.0.0:*" : ""),
        ].join(' '),
      },
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only if not running tests
  if (process.env.NODE_ENV !== 'test') {
    mainWindow.webContents.openDevTools();
  }
};

ipcMain.on('auth:start-login', async () => {
  console.log('Starting OIDC login flow...');

  try {
    // 1. Discover OIDC provider metadata and create config
    const config = await openidClient.discovery(
      new URL(`https://${auth0Domain}`),
      auth0ClientId,
      { redirect_uris: [redirectUri], response_types: ['code'] },
      openidClient.None()
    );

    // 2. Generate a code verifier and challenge for PKCE
    codeVerifier = openidClient.randomPKCECodeVerifier();
    const codeChallenge = await openidClient.calculatePKCECodeChallenge(codeVerifier);

    // 3. Store the OIDC config for later use
    authConfig = config;

    // 4. Construct the authorization URL
    const authUrl = openidClient.buildAuthorizationUrl(config, {
      scope: 'openid profile email offline_access',
      response_mode: 'query',
      code_challenge: codeChallenge,
      code_challenge_method: 'S256',
      redirect_uri: redirectUri,
    });

    console.log('Opening external browser for authentication...');
    await shell.openExternal(authUrl.toString());

  } catch (err) {
    console.error('Error during login flow:', err);
  }
});

// This function will handle the authentication callback
function handleAuthCallback(url: string) {
  (async () => {
    if (!authConfig || !codeVerifier) {
      console.error('OIDC config or code verifier not available.');
      return;
    }

    try {
      const tokenSet = await openidClient.authorizationCodeGrant(authConfig, new URL(url), {
        pkceCodeVerifier: codeVerifier,
      });

      // Check if a refresh token exists and store it securely
      if (tokenSet.refresh_token) {
        await keytar.setPassword(keytarService, keytarAccount, tokenSet.refresh_token);
        console.log('Refresh token stored securely.');
      }

      // Fetch userinfo if available
      let userinfo = {};
      if (tokenSet.access_token) {
        userinfo = await openidClient.fetchUserInfo(authConfig, tokenSet.access_token, openidClient.skipSubjectCheck);
      }

      console.log('Successfully retrieved tokens and user info!');
      mainWindow?.webContents.send('auth:success', userinfo);

      // Bring the app window to the front
      if (mainWindow) {
        if (mainWindow.isMinimized()) mainWindow.restore();
        mainWindow.focus();
      }
// Logout IPC handler
ipcMain.on('auth:logout', async () => {
  console.log('Logging out and clearing tokens...');
  await keytar.deletePassword(keytarService, keytarAccount);
  // Optionally, you can also redirect to the Auth0 logout endpoint.
  mainWindow?.webContents.send('auth:logged-out');
});

    } catch (err) {
      console.error('Error exchanging code for tokens:', err);
      // You could also send an 'auth:failure' event to the renderer here
    }
  })();
}

// Protocol event handlers (outside createWindow)

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
// This must be the first block of code in the file.
app.on('ready', () => {
if (process.env.NODE_ENV === 'test') {
  app.commandLine.appendSwitch('remote-debugging-port', '9222');
}
  // Register custom protocol handler before window creation
  if (process.defaultApp) {
    if (process.argv.length >= 2) {
      app.setAsDefaultProtocolClient('myapp', process.execPath, [path.resolve(process.argv[1])]);
    }
  } else {
    app.setAsDefaultProtocolClient('myapp');
  }

  createWindow();

  // Handle macOS 'open-url' event
  app.on('open-url', (event, url) => {
    event.preventDefault();
    void handleAuthCallback(url);
  });

  // Handle Windows/Linux protocol launch
  const gotTheLock = app.requestSingleInstanceLock();
  if (!gotTheLock) {
    app.quit();
  } else {
    app.on('second-instance', (event, commandLine) => {
      // Someone tried to run a second instance, we should focus our window.
      if (mainWindow) {
        if (mainWindow.isMinimized()) mainWindow.restore();
        mainWindow.focus();
      }
      // The commandLine contains the full URL, find it
      const url = commandLine.pop();
      if (url && url.startsWith('myapp://')) {
        void handleAuthCallback(url);
      }
    });
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
// Forward 'auth:success' from renderer (for testing)
ipcMain.on('auth:success', (_event, userProfile) => {
  mainWindow?.webContents.send('auth:success', userProfile);
});
